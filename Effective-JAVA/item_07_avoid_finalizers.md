## 2장 객체의 생성과 삭제

### 규칙 7. 종료자(finalizers)를 피하라.



<br>



종료자(finalizers)는 예측 불가능하며, 대체적으로 위험하고, 불필요하다.

종료자를 사용하면 시스템 오류, 성능 문제, 이식성 문제가 발생할 수 있다.

> 자바의 종료자는 C++의 destructor와는 다르다. 



<br>



#### 종료자의 단점

##### 즉시 실행되리라는 보장이 없으며, 종료자를 사용하면 프로그램 성능이 심각하게 떨어진다. 

어떤 객체에 대한 모든 참조가 사라지고 나서 종료자가 실행되기까지 긴 시간이 걸릴 수도 있다.

**따라서 긴급한 작업을 종료자 안에서 처리하면 안된다.**

> 대표적으로 file descriptor 같은 유한한 자원은 종료자에서 파일을 닫도록 하면 안된다.
>
> 혹은 지속성이 보장되어야 하는 중요 상태 정보(critical persistent state)는 종료자로 갱신하면 안된다.

종료자의 실행 시점은 가비지컬렉터 알고리즘에 좌우되며, 이 알고리즘은 JVM의 구현에 따라 크게 다르다. 즉 JVM마다 다른 시점에 동작한다.

종료자의 더딘 실행(tardy finalization)은 객체 메모리의 반환 또한 지연되어 OutOfMemoryError도 발생 할 수 있다.



<br>



파일이나 스레드처럼 명시적으로 반환되거나 삭제해야 하는 자원을 포함하는 객체의 클래스의 경우에, 종료자가 아니라 **명시적인 종료 메서드(termination method)**를 하나 정의하는것이 더 낫다.

더 이상 필요하지 않은 객체라면 클라이언트가 해당 메서드를 호출하도록 하고, 종료 여부를 객체 안의 private 필드에 보관한다. 

종료 여부 필드를 모든 메서드의 맨 앞에 검사하도록 하여 이미 종료된 객체에 메서드를 호출하면 IllegalStateException을 던지도록 한다.

> 이런 명시적 종료 메서드의 대표적인 예로는 OutputStream이나 InputStream, java.sql.Connection에 정의된 close 메서드와
>
> Java.util.Timer 클래스의 cancel 메서드, java.awt의 Graphics.dispose, Window.dispose 등이 잇다.

이런 명시적 종료 메서드는 보통 객체 종료를 보장하기 위해 try-finally 문과 함께 쓰인다.

```java
Foo foo = new Foo(...);
try {
  ...
} finally {
  foo.close(); //명시적 종료 메서드
}
```



<br>



또한 자바 1.7 이후에는 try-with-resource문을 지원하여 finally 구문을 사용하지 않고 좀 더 깔끔한 구현이 가능하다.

```java
try (Foo foo = new Foo(...)){
  ...
}
```



<br>



#### 종료자의 사용이 적합할 경우

#####명시적 종료 메서드 호출을 잊을 경우를 대비하는 안전망(safety net)으로서의 역할로 사용된다.

종료자는 명시적 종료 메서드의 호출을 잊은 자원을 발견하게 될 경우, 경고 메시지를 로그로 남겨야 한다.

앞서 예를 든 명시적 종료 메서드 패턴을 따르는 클래스들 또한 종료 메서드가 호출되지 않을때를 대비해 종료자 안전망을 갖추고 있다. (다만 로그는 남기지 않고 있다.)



<br>



#####네이티브 피어(native peer)와 연결된 객체를 다룰 때 사용된다.

네이티브 피어는 일반 객ㅊ가 네이티브 메서드(native method)를 통해 기능 수행을 위임하는 네이티브 객체를 말한다. 

네이티브 피어는 일반 객체가 아니므로 가비지 컬렉터가 알 수 없을 뿐더러 자바 측 피어 객체(Java peer)가 반환 될 떄 같이 반환 될 수도 없다.

네이티브 피어가 즉시 종료 되어야 하는 자원을 포함하지 않은 경우에 종료자를 사용한다.



<br>



#### 종료자 연결 (finalizer chaining)

종료자 연결 (finalizer chaining)은 자동으로 이루어지지 않는다.

어떤 클래스가 종료자를 가지고 있고, 해당 클래스를 상속받아 종료자를 오버라이드 하는 경우, 자식 클래스는 상위 클래스의 종료자를 명시적으로 호출 해야 한다.



<br>



##### 수동 종료자 연결 (Manual finalizer chaining)

```java
//수동 종료자 연결 (Manual finalizer chaining)
@Override
protected void finalize() throw Throwable(){
  //자식 클래스의 종료자 실행시 예외가 발생해도 부모 클래스의 종료자를 실행 할 수 있도록 try-finally 구문을 이용한다.
  try {
    ... //하위 클래스 상태를 종료함.
  } finally {
    super.finalize();
  }
}
```



<br>



##### 종료 보호자 (Finalizer Guardian)

만약 하위 클래스에서 상위 클래스 종료자를 오버라이드 하면서 상위 클래스 종료자 호출을 잊으면, 상위 클래스 종료자는 절대 호출되지 않는다. 

이런 문제를 방지하는 방법중 하나는 종료되어야 하는 모든 객체마다 여벌의 객체를 하나 더 만드는 것이다.

종료되어야 하는 객체의 클래스 안에 종료자를 정의하는 대신, 익명 클래스(anonymouse class)안에 종료자를 갱신하는 것이다.

이 익명 클래스의 목적은 해당 클래스의 객체를 포함하는 객체를 종료시키는 것이다. 이러한 익명 클래스 객체를 **종료 보호자(Finalizer guardian)**라고 부른다.

```java
public class Foo {
  private final Object finalizerGuardian = new Object() {
    @Override
    protected void finalize() throws Throwable {
      ... // 바깥 Foo 객체를 종료시킴.
    }
  }
}
```

Foo 객체가 가비지 컬렉터에 의해 제거될 때, 종료 보호자도 실행 가능한 상태가 되어 바깥 객체를 종료시킨다.



<br>



#### 정리

1. 종료자는 장점이라곤 거의 없으니, 자원 반환의 안전장치, 혹은 그다지 중요하지 않은 네이티브 자원의 종료 외에는 사용하지 말자.
2. 사용하게 될 상황에서는 super.finalize()의 호출은 잊지 말자. 혹은 종료 보호자 패턴의 도입을 고민하자.

